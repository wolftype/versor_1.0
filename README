Versor (vsr) library for Conformal Geometric Algebra.  See Copyright notice (GPL).  

Contact:    Pablo Colapinto
Email:      wolftype@gmail.com

README CONTENTS: 

INTRODUCTION | ELEMENTS AND OPERATORS | COMPILATION | DEPENDENCIES

////////////
INTRODUCTION
------------

Welcome to Versor!  This package provides operations and draw routines for conformal geometric algebra. It is designed to make graphical experimentation of geometric algebra within a C++ environment easier.  It comes bundled with a GPL gui builder (mat.ucsb.edu/glv/) made by my colleagues in the MAT program.  You can use this library to draw geometrical things, explore spherical and hyperbolic spaces, transformations, design robots, etc.  I am using it for my PhD on biological simulations.

I developed "Versor" while reading "Geometric Algebra for Computer Science" by Leo Dorst, Daniel Fontijne, and Stephen Mann.  It's a great book.  Built to aid in my modelling of biological forms, this work was funded in large part by the Olivia Long Converse Fellowship, from the Graduate Division at the University of California in Santa Barbara.  So this is under a UC Regents General Public License.

See also wolftype.com/versor for a link to my master's thesis on CGA and this implementation of it, and maybe take a look at wolftype channel on vimeo for a few quick demos on what kinds of animations this thing can quickly whip up.  The Doc folder has a doxygen which I periodically tidy up.  Lots of test files too.  Still need to streamline the make process, etc.

Note to speed freaks: check out the vsr_static project for a highly templatized and inlined extravaganza of function calls.  There is a trade off I am working on (in a branch to this master called "building and MVBase class") where you have an MVBase class with which you can make arbitrary functions.  This requires a bunch of pointer being copied but seems like a harmless trade off.   

A tutorial is in the works . . . I promise!  For now consider the test examples.  One quick word: clifford algebras and the spatial relationships they embody can often feel abstract and daunting.  But it's a twisty, boosty ride, full of weird discoveries.  You're bound to make some, so have fun!

///
GUI
---
The TestExamples include bindings to the GLV framework, along with a GLVApp class, which has a GLVInterface class.
    The interface has a built in gui, mouse info, and keyboard info stored.  
    
    Putting "app.interface.touch(<element>)" inside your draw loop will enable you to click and modify geometric elements by hitting the "G", "R" and "S" keys.  Hit "Q" to deselect all elements.  
    
    Hit "~" to toggle full screen.
    
    Holding down the "SHIFT" key while navigating with the arrow buttons moves the camera around.
    Holding down the "OPTION" key while navigating with the arrow buttons spins the model view around.

//////////////////////
ELEMENTS AND OPERATIONS
----------------------

Without going into too much detail, there are three overloaded binary operators: 

*    The Geometric Product
^    The Outer Product
<=   The Inner Product

[There is also % which is a commutator product]

And a few overloaded operations:

! or -  Inverse
~       Reverse

And finally, since I ran out of overloadable operators, some basic methods

conjugate()
involute()


A * B   multiplies two elements together (and, in the case of A * !B (or A * -B), finds ratios between elements)
A ^ B   wedges two elements together ( builds up higher dimensional elements )
A <= B  contracts A out of B ( returns the part of B least like A )

Operators act on the elements of the algebra.  The elements are geometric entities.  To make the process of writing code faster and consistent, all elements of the algebra are 3 letters long.

"EUCLIDEAN ELEMENTS"
Sca -- Scalar       (A real number)
Vec -- Vector       (A Directed Magnitude, or 3D Vector, typical cartesian stuff)
Biv -- Bivector     (A Directed Area. Use them to make Rotors (aka Quaternions): Gen::Rot( Biv b ) )
Tri -- Trivector    (A Directed Volume Element)

"ROUND ELEMENTS"
Pnt -- Point            (Pnt a) (Pnt a = Vec(1,0,0).null() ) 
Par -- Point Pair       (Pnt a ^ Pnt b)
Cir -- Circle           (Pnt a ^ Pnt b ^ Pnt c)
Sph -- Sphere           (Pnt a ^ Pnt b ^ Pnt c ^ Pnt d)
Dls -- Dual Sphere      (same as a point, so: typedef Pnt Dls)

"FLAT ELEMENTS"
Lin -- Line
Dll -- Dual Line
Pln -- Plane
Dlp -- Dual Plane

"ABSTRACT ELEMENTS"
Mnk -- Minkowski Plane
Pss -- PseudoScalar (5D)
Inf -- Infinity

"VERSORS"
Rot -- Rotor 
Trs -- Translator
Dil -- Dilator
Mot -- Motor
Trv -- Transversor

There are also built in macros, for instance
EP  -- Imaginary Sphere At the Origin. 
EM  -- Sphere at the Origin.  
INF -- Infinity

EP and EM can be invoked instead of INF to work in non-Euclidean metrics ( Hyperbolic and Spherical, respectively)

Most elements can be drawn by invoking the draw() method.  Some can't (yet) either because it wasn't obvious
how to draw them (e.g the scalar) or because I just didn't figure out how to do it or because I forgot.  If you
want something to be drawable, let me know and I'll add it in.

<element>.draw() 
or by feeding in r,g,b values
<element>.draw(float r, float g, float b )
or by feeding in r,g,b,a values
<element>.draw(float r, float g, float b, float a )


All elements can be dualized by invoking <element>.dual()

All elements can be reflected over spinors with the sp() method

All elements can be reflected over versors with the re() method

The versors are constructed by the geometric entities, typically by using the Gen:: routines.  Operators can also be acted on by operators -- you can rotate a translation, or twist a boost.

///////////////
COMPILATION
---------------
TO "INSTALL" ON MAC OSX:
For now, you'll need to use the built in xcode project, and run "TestVsrGlv.app".  

The Xcode project in OSX/vsr/ takes care of the multistage compilation process.
It creates and embeds a cga (conformal geometric algebra) framework for calculating multivectors into  
libvsr.a, a library that calls the functions in the cga framework and does other nifty things
(like helps with draw routines and helps with common operations).  Take a look at Op.h.

Versor is designed to run on other platforms but not currently tested.  A static library version
is in the works.  It should run faster.

Documentation can be found at wolftype.com/versor 
This is my first program!  Feel free email me at wolftype@gmail.com

/////////////
DEPENDENCIES
-------------
libvsr.a is a graphics library and so requires OpenGL.  The included tests link to GLUT and GLV, which comes included.  
(Made by my colleagues at MAT program at UCSB, GLV is good for quick and easy OpenGL guis).



